[参考](https://blog.csdn.net/u013351484/article/details/50789521)
# 零和博弈
假设博弈双方都采取对于自己最有利的策略    
假设我们为每一个局面一个估价函数f()表示对于某一方的有利程度，则有：   
max局面---己方走，这时我们选择估价函数最大的局面     
min局面---对方走，这时由于对方采取最优策略，对己方的价值最小，因此我们的估价函数一个为f()的最小值      
ccf棋局评估
```
#include <bits/stdc++.h>
using namespace std;
int mp[3][3];
//判断是否比赛结束
bool isv(int k){
    for(int i=0;i<3;i++){
        if(mp[i][0]==k&&mp[i][1]==k&&mp[i][2]==k)return true;
        if(mp[0][i]==k&&mp[1][i]==k&&mp[2][i]==k)return true;

    }
    if(mp[0][0]==k&&mp[1][1]==k&&mp[2][2]==k)return true;
    if(mp[0][2]==k&&mp[1][1]==k&&mp[2][0]==k)return true;
    return false;
}
int dfs(int k){
    int t=0;
    for(int i=0;i<3;i++){
        for(int j=0;j<3;j++){
            if(mp[i][j]==0)t++;
        }

    }
    //找到未下棋的数目
    if(k==1&&isv(2))return -t-1;
    if(k==2&&isv(1))return t+1;
    if(t==0)return 0;
    int mn=0x3f3f3f3f,mx=-0x3f3f3f3f;
    for(int i=0;i<3;i++){
        for(int j=0;j<3;j++){
            if(mp[i][j]==0){
                mp[i][j]=k;
                //k=1表示轮到1下棋，这时选择子局面（2下棋）中对我们最有利的局面
                if(k==1)mx=max(mx,dfs(2));//max函数
                if(k==2)mn=min(mn,dfs(1));//min函数
                mp[i][j]=0;
            }
        }
        
    }
    if(k==1)return mx;
    if(k==2)return mn;

}
int main(){
    int T;
    cin>>T;
    while(T--){
        for(int i=0;i<3;i++){
            for(int j=0;j<3;j++){
                cin>>mp[i][j];
            }
        }
        cout<<dfs(1)<<endl;
    }

    return 0;
}
```