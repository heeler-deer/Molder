# 最大流最小费用问题
凡是网络流题目，都要建双向边，**建边模板：**
```
class Graph{
    public:
         int top,to[M<<1],fw[M<<1],ct[M<<1];
         //top表示边数，to[x]表示这条边到达的节点，fw是流量，ct是花费

         vector<int> g[V];
         Graph(){top=1;}
         void add(int x,int y,int f,int c){
             g[x].push_back(++top);
             to[top]=y;
             fw[top]=f;
             ct[top]=c;
         }
         void Add(int x,int y,int f,int c){
             add(x,y,f,c);
             add(y,x,0,-c);
             //双向边
         }
}
```
最小费用最大流模板
```
void mcmf(){
    while(spfa()){
        vis[t]=1;
        while(vis[t]){
            for(int i=1;i<=p;i++)vis[i]=0;
            fans+=dfs(s,inf);
        }
    }
}
//fans是最大流，cans是最小费用，在dfs中求
```
## zkw最大流
参考[博客](https://www.cnblogs.com/George1123/p/12444602.html)
**特点：**较大费用流图，最大流流经好多路径，时较快     
spfa的以边的费用为边权，从t到s反向跑最短路，他的作用：
1. 分出点的层次，使增广有序
2. 跑出最短路，保证最小费用
3. 算出连通性，抉择增广
```
bool spfa(){
    for(int i=1;i<=p;i++)vis[i]=0,dep[i]=inf;
    q.push_back(t),vis[t]=1,dep[t]=0;
    while(q.size()){
        int x=q.front();q.pop_front(),vis[x]=0;
        for(auto i:g[x])if(fw[i^1]&&dep[to[i]]>dep[x]-ct[i]){
            dep[to[i]]=dep[x]-ct[i];
            if(!vis[to[i]]){
                vis[to[i]]=1;
                if(q.size()&&dep[to[i]]<dep[q.front()])q.push_front(to[i]);
                else q.push_back(to[i]);
            }
        }
    }
    return dep[s]<inf;
}
```
接下来是增广的dfs，与spfa不同的是，正着跑图可以避免dep每次增广前都浪费时间重新算
```
int dfs(int x,int F){
    vis[x]=1;
    if(x==t||!F)return F;
    //到达终点或者没流量了
    int f,flow=0;
    for(auto i:g[x])if(!vis[to[i]]&&fw[i]&&dep[x]-ct[i]==dep[to[i]]&&(f=dfs(to[i],min(F,fw[i])))>0){
       //节点未经过，该边有流量，dep保证是低层次到高层次增广，f为世纪可流的流量
        cans+=f*ct[i],fw[i]-=f,fw[i^1]+=f,flow+=f,F-=f;
        if(!F)break;
    }
    return flow;
}
```
**洛谷**[P3381](https://www.luogu.com.cn/problem/P3381)
```
#include <bits/stdc++.h>
using namespace std;
const int V=1e6;
const int M=3e6;
const int inf=0x3f3f3f3f;
int n,m,s,t,p,fans,cans;
class Graph{
public:
	int top,to[M<<1],fw[M<<1],ct[M<<1];
	vector<int> g[V];
	Graph(){top=1;}
	void add(int x,int y,int f,int c){
		g[x].push_back(++top);
		to[top]=y,fw[top]=f,ct[top]=c;
	}
	void Add(int x,int y,int f,int c){
		add(x,y,f,c),add(y,x,0,-c);
	}
};
class zkwMCMF:public Graph{
public:
	int dep[V];	bool vis[V];
	deque<int> q;
	bool spfa(){
		for(int i=1;i<=p;i++) vis[i]=0,dep[i]=inf;
		q.push_back(t),vis[t]=1,dep[t]=0;
		while(q.size()){
			int x=q.front();q.pop_front(),vis[x]=0;
			for(auto i:g[x])if(fw[i^1]&&dep[to[i]]>dep[x]-ct[i]){
				dep[to[i]]=dep[x]-ct[i];
				if(!vis[to[i]]){
					vis[to[i]]=1;
					if(q.size()&&dep[to[i]]<dep[q.front()])
						q.push_front(to[i]);
					else q.push_back(to[i]);
				}
			}
		}
		return dep[s]<inf;
	}
	int dfs(int x,int F){
		vis[x]=1;
		if(x==t||!F) return F;
		int f,flow=0;
		for(auto i:g[x])if(!vis[to[i]]&&fw[i]&&dep[x]-ct[i]
		==dep[to[i]]&&(f=dfs(to[i],min(F,fw[i])))>0){
			cans+=f*ct[i],fw[i]-=f,fw[i^1]+=f,flow+=f,F-=f;
			if(!F) break;
		}
		return flow;
	}
	void mcmf(){
		while(spfa()){
			vis[t]=1;
			while(vis[t]){
				for(int i=1;i<=p;i++) vis[i]=0;
				fans+=dfs(s,inf);
			}
		}
	}
}network;
int main(){
	scanf("%d%d%d%d",&n,&m,&s,&t),p=n;
	for(int i=1,x,y,f,c;i<=m;i++){
		scanf("%d%d%d%d",&x,&y,&f,&c);
		network.Add(x,y,f,c);
	}
	network.mcmf();
	printf("%d %d\n",fans,cans);
	return 0;
}
```
之后我发现了作者给的模板源码：
```
//Mincostmaxflow
const int V=8002;
int no,s,t,flow,cost;
vector<int> to,fw,co,e[V+7];
void add(int u,int v,int f,int c){
	e[u].pb(sz(to)),to.pb(v),fw.pb(f),co.pb(+c);
	e[v].pb(sz(to)),to.pb(u),fw.pb(0),co.pb(-c);
}
int vis[V+7],dep[V+7];
int Bfs(){
	for(int i=1;i<=no;i++) vis[i]=0,dep[i]=inf;
	vector<int> q; q.pb(t),vis[t]=1,dep[t]=0;
	for(int x=0;x<sz(q);x++)
		for(int i:e[q[x]])if(fw[i^1]&&dep[to[i]]>dep[q[x]]-co[i])
			dep[to[i]]=dep[q[x]]-co[i],!vis[to[i]]&&(q.pb(to[i]),vis[to[i]]=1);
	return dep[s]<inf;
}
int Dfs(int x,int fn){
	vis[x]=1; if(x==t||!fn) return fn; int f,res=0;
	for(int i:e[x])if(!vis[to[i]]&&fw[i]&&dep[x]-co[i]==dep[to[i]]&&(f=Dfs(to[i],min(fn,fw[i])))>0)
		{cost+=f*co[i],fw[i]-=f,fw[i^1]+=f,res+=f,fn-=f;if(!fn) break;}
	return res;
}
void Mcmf(){
	while(Bfs()) for(vis[t]=1;vis[t];){
		for(int i=1;i<=no;i++) vis[i]=0;
		flow+=Dfs(s,inf);
	}
}
```
**orz**
## EK最大流
**特点：**较大费用流图，路径长且最大流路径单一    

