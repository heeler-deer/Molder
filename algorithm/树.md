# 树
## 树的直径
[题目](http://118.190.20.162/view.page?gpid=T24)
参考[博客](https://blog.csdn.net/forever_dreams/article/details/81051578)
树的直径：在树中找出两个结点，使两个结点的距离最长，这个距离称为直径。   
求法：
1. 两次bfs/dfs：任选一个结点，先找到距离s最远的结点start,再从start开始，再找到距离start最远的结点end，得到结果即为start->end。
2. dp解法，看能否更新最大值，若能，则更新，原先最大值变为次大值；若不能，则看能不能更新次大值，最终答案为最大值与次大值的和
dfs/bfs略    
**树形dp:**
```
#include <bits/stdc++.h>
using namespace std;
const int N=100005;
int n,m,t,ans;
int f1[N],f2[N];
int first[N],v[N],w[N],next[N];
void add(int x,int y,int z){
    t++;
    next[t]=first[x];
    first[x]=t;
    v[t]=y;
    w[t]=z;
}
void dp(int x,int father){
    int i,j;
    for(i=first[x];i;i=next[i]){
        j=v[i];
        if(j==father)continue;
        dp(j,x);
        if(f1[x]<f1[j]+w[i])
		{
			f2[x]=f1[x];
			f1[x]=f1[j]+w[i];
		}
		else if(f2[x]<f1[j]+w[i])
		  f2[x]=f1[j]+w[i];
		ans=max(ans,f1[x]+f2[x]);
	

    }
}
int main()
{
	int x,y,z,i;
	scanf("%d%d",&n,&m);
	for(i=1;i<=m;++i)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
		add(y,x,z);
	}
	dp(1,0);
	printf("%d",ans);
	return 0;
}
```