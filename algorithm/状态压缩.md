# ccf
## 状压dp
通常使用在np小问题的求解中，速度比搜索快。
### 位运算
x&y: 二进制下进行与运算，返回十进制下的值    
3（11）&2（10）=2（10）     
x|y：或运算，3|2=3(11)     
x^y：异或运算，3^2=1（01），相同为0，不同为1；    
x<<2,相当于乘以4，x>>1，相当于除以2     

### 例题
#### 填满棋盘---
>有一个NM(N<=5,M<=1000)的棋盘，现在有12及2*1的小木块无数个，要盖满整个棋盘，有多少种方式？答案只需要mod1,000,000,007即可。
例如：对于一个22的棋盘，有两种方法，一种是使用2个12的，一种是使用2个2*1的。   

思路：参考[博客](https://blog.nowcoder.net/n/fcc30eadb2b44395862194814e819315?from=nowcoder_improve)，我们可以这样思考，假设一列一列的填充棋盘，那么我们填充第i列时只需要考虑第i-1列对他的影响（前i-1列已经填充完成），我们需要判断的是第i-1列在填充时是否会占用到第i列的格子。通过观察数据，我们发现n是很小的，而m很大。那么我们可以尝试采用搜索的方式对每一列的状态进行枚举。    
要简化就要用到状压，以一个二进制数来表示每一种状态，如我们可以用00100来表示某一列的第三个格子被占用，即以一个n位的二进制数state来表示可能的状态，显然十进制state很小。   
既然是dp,那么按照上面的思路，我们用dp[i][state]来表示枚举第i列时第i-1列对他的影响为(state)(占用的格子)时的合法的方法数。    
如此，最终求的答案就是dp[m+1][0](m列未占用格子)
````
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int M=2007;
const ll mod=1000000007;
ll dp[M][M];
ll n,m;
//第i列第j行
void dfs(ll i, ll j,ll state,ll nex){
    //如果该列的枚举到了第n行，就相加。
if(j==n){
    dp[i+1][nex]+=dp[i][state];
    dp[i+1][nex]%=mod;
    return;
}
//该格子被占
if((1<<j)&state>0){
    dfs(i,j+1,state,nex);//nex不变
}
//未被占则横着放
if((1<<j)&state==0){
    dfs(i,j+1,state,nex|(1<<j));
// nex的第j位变为1

}
//两个格子未被占则竖着放
if((j+1<n)&&((1<<j)&state==0)&&((1<<(j+1))&state==0)){
    dfs(i,j+2,state,nex);//nex不变
}
return;
}
int main(){
    while(cin>>n>>m){

        memset(dp,0,sizeof(dp));
        if(n==0&&m==0)break;
        dp[1][0]=1;
        for(int i=0;i<m;i++){
            for(int j=0;j<(1<<n);j++){//j是state的十进制数，枚举
                if(dp[i][j])dfs(i,0,j,0);
            }
        }
        cout<<dp[m+1][0];
    }
    return 0;
}
````
#### 牛吃草---
>农场主John新买了一块长方形的新牧场，这块牧场被划分成M行N列(1 ≤ M ≤ 12; 1 ≤ N ≤ 12)，每一格都是一块正方形的土地。John打算在牧场上的某几格里种上美味的草，供他的奶牛们享用。遗憾的是，有些土地相当贫瘠，不能用来种草。并且，奶牛们喜欢独占一块草地的感觉，于是John不会选择两块相邻的土地，也就是说，没有哪两块草地有公共边。John想知道，如果不考虑草地的总块数，那么，一共有多少种种植方案可供他选择？（当然，把新牧场完全荒废也是一种方案）



[链接](https://www.luogu.com.cn/problem/P1879)    
思路：[博客](https://blog.csdn.net/Erin_jwx/article/details/108036198)

```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int F[15];
int a[15][15];
bool g[1<<12+5];
int dp[15][1<<12+5];
int mod=1e8;
int main(){

    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>a[i][j];
            F[i]=(F[i]<<1)+a[i][j];//fi表示i行状态，读入一个数就加入末尾
        }
    }
    
        for(int j=0;j<(1<<m);j++){
              g[j]=(!((j<<1)&j))&&(!((j>>1)&j));
            ///gi表示当前格子是否左右相邻
        }
    dp[0][0]=1;
    for(int i=0;i<n;i++){
        for(int j=0;j<(1<<m);j++){
            if(g[i]&&((j&F[i])==j)){//如果左右不相邻且j的状态与fi的状态相同
                for(int k=0;k<(1<<m);k++){
                    if((k&j)==0){//判断上下是否相邻
                        dp[i][j]=(dp[i][j]+dp[i-1][k])%mod;
                    }
                }
            }
        }
    }
     int ans=0;
     for(int i=0;i<(1<<m);i++){
         ans+=dp[n][i];//dp n i表示第n行是方案i时的方案数
         ans%=mod;
     }
     cout<<ans<<endl;
    return 0;
}
```
