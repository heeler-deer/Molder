```
//求m^k%p
int qmi(int m, int k, int p)
{
    int res = 1 % p, t = m;
    while (k)
    {
        if (k&1) res = res * t % p;
        t = t * t % p;
        k >>= 1;
    }
    return res;
}
==================================================================
//求a^n
int qpow(int a, int n){
    int ans = 1;
    while(n){
        if(n&1)        //如果n的当前末位为1
            ans *= a;  //ans乘上当前的a
        a *= a;        //a自乘
        n >>= 1;       //n往右移一位
    }
    return ans;
}
```
矩阵快速幂就是把快速幂的乘法改为矩阵乘法    
```
const int N=10;
 
int tmp[N][N];
 
void multi(int a[][N],int b[][N],int n)
 
{
 
memset(tmp,0,sizeof tmp);
 
for(int i=0;i<n;i++)
 
for(int j=0;j<n;j++)
 
for(int k=0;k<n;k++)
 
tmp[i][j]+=a[i][k]*b[k][j];
 
for(int i=0;i<n;i++)
 
for(int j=0;j<n;j++)
 
a[i][j]=tmp[i][j];
 
}
 
int res[N][N];//结果存放在res当中
 
void Pow(int a[][N],int n)
 
{
 
memset(res,0,sizeof res);//n是幂，N是矩阵大小
 
for(int i=0;i<N;i++) res[i][i]=1;
 
while(n)
 
{
 
if(n&1)
 
multi(res,a,N);//res=res*a;复制直接在multi里面实现了；
 
multi(a,a,N);//a=a*a
 
n>>=1;
 
}
 
}
```